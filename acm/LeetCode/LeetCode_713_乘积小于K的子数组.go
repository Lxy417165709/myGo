package main




func numSubarrayProductLessThanK(nums []int, k int) int {
	ans := 0	// 答案
	l,r:=0,0	// 左右窗口指针
	sum:=1		// 保存的是nums[l]...nums[r]的乘积
	for r<len(nums){
		sum*=nums[r]	// 记录窗口拓展后的乘积
		// 判断窗口是否需要缩小(缩小方式是l前移)
		for l<=r && sum>=k{
			sum/=nums[l]
			l++
		}
		// 根据所得窗口大小，增加解决方案
		ans+=(r-l+1)

		// 窗口拓展
		r++
	}
	return ans
}

/*
	总结
	1. 刚刚开始做的时候用了暴力，将每个 乘积[i,x] (x>=0 && x<i)的乘积与k比较，满足则
		ans++，否则比较下一个i。显然超时了。
	2. 第二次就想到了滑动窗口，于是顺利AC了这个题目。思路是: 维持[l,r]的乘积窗口，当纳入一个数后
		窗口乘积大于k，那就l向右推进，直到小于k。注意: 每纳入一个数，我们可以增加 (r-l+1)种方案哦。
		（比如 1 2 4,我们纳入5后满足时，我们多了这些解决方案 5,5 4,5 4 2, 5 4 2 1）
	3. 官方有用二分+对数的方法AC的，很妙。

*/
