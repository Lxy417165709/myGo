package 双指针

import "fmt"

const (
	inf = 1000000000
)

func change(amount int, coins []int) int {
	if amount <0 {
		return 0
	}
	dp := [5050]int{}	// dp[i]表示 凑成金额i的硬币组合种数
	dp[0] = 1

	// 这样求的是排列(爬楼梯升级版)
	// 因为我们求的是排列，硬币的选择并不会受先前的决定影响
	// 所以此时把硬币放在内部循环，这样每次都能选择所有的硬币
	// for i:=1;i<=amount;i++{
	//     for t:=0;t<len(coins);t++{
	//         if i>=coins[t]{
	//             dp[i] += dp[i-coins[t]]
	//         }
	//     }
	// }

	// 这样求的是组合..
	// 因为我们求的是组合，硬币的选择会受先前的决定影响
	// 所以此时把硬币放在外部循环，可以保证接下来构成总金额i时不会再使用前面的硬币，这样才能保证组合的唯一性
	// 比如(1 2) (2 1) 这种是同一组合，(2 1)产生的原因是，我们在得3的时候，使用到了1
	for t:=0;t<len(coins);t++{
		for i:=1;i<=amount;i++{
			if i>=coins[t]{
				dp[i] += dp[i-coins[t]]
			}
		}
	}

	return dp[amount]
}

/*
	总结
	1. 这题之前做过，然后现在是重做了一次。
	2. 对于不关心排列组合的，内外循环其实可以倒置(自己猜想的)，而要求排列的，外部循环必须是尾数(比如斐波那契尾数为1,2)
		而要求排列的，外部循环必须是所需数。

*/
