package main

import (
	"fmt"
	"strconv"
)

func rangeBitwiseAnd(m int, n int) int {
	str:=""
	for ;m!=0; {
		if m!=n {
			str="0"+str
		}else{
			if m%2==1{
				str="1"+str
			}else{
				str="0"+str
			}
		}
		m>>=1
		n>>=1
	}
	if str=="" {
		str="0"
	}


	x,_ := strconv.ParseInt(str,2,64)

	return int(x)
}


func main() {
	fmt.Println(rangeBitwiseAnd(0,8))
}
/*
	总结
	1. 我的判断依据是[m,n]范围内是否有偶数，有偶数则最低位为0，否则为1
	2. 官方有更好的方法 0.0.
	3. 他的依据是：通过数学推导，可以得出题目其实等价于求m和n从高位开始，有多少位是相同的，这些相同的位组成的数就是答案

大佬解答：
【笔记】当一个数+1时，总会有这么一个规律“某一位后的数字，全部被置为相反数”。举个例子：

010111 + 1 = 011000，则010111 & 011000 = 010000。那么，x & (x+1) 后几位相反数的“与操作”，结果总为0。

所以，当(m,m+1,...n-1,n)进行连续“与操作”时，会按照上述规律被抵消很大一部分，而只剩下n的前缀部分，最后只需将n归位。举个例子：

m = 5(0101), n = 7 (0111)。不停右移，得到n前缀部分为01，最后归位前缀得res=0100=4



*/